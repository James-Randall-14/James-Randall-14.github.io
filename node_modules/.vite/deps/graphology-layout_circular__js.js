import {
  require_is_graph
} from "./chunk-ULR5OFWV.js";
import {
  __commonJS
} from "./chunk-5WRI5ZAA.js";

// node_modules/graphology-utils/defaults.js
var require_defaults = __commonJS({
  "node_modules/graphology-utils/defaults.js"(exports, module) {
    function isLeaf(o) {
      return !o || typeof o !== "object" || typeof o === "function" || Array.isArray(o) || o instanceof Set || o instanceof Map || o instanceof RegExp || o instanceof Date;
    }
    function resolveDefaults(target, defaults) {
      target = target || {};
      var output = {};
      for (var k in defaults) {
        var existing = target[k];
        var def = defaults[k];
        if (!isLeaf(def)) {
          output[k] = resolveDefaults(existing, def);
          continue;
        }
        if (existing === void 0) {
          output[k] = def;
        } else {
          output[k] = existing;
        }
      }
      return output;
    }
    module.exports = resolveDefaults;
  }
});

// node_modules/graphology-layout/circular.js
var require_circular = __commonJS({
  "node_modules/graphology-layout/circular.js"(exports, module) {
    var resolveDefaults = require_defaults();
    var isGraph = require_is_graph();
    var DEFAULTS = {
      dimensions: ["x", "y"],
      center: 0.5,
      scale: 1
    };
    function genericCircularLayout(assign, graph, options) {
      if (!isGraph(graph))
        throw new Error(
          "graphology-layout/random: the given graph is not a valid graphology instance."
        );
      options = resolveDefaults(options, DEFAULTS);
      var dimensions = options.dimensions;
      if (!Array.isArray(dimensions) || dimensions.length !== 2)
        throw new Error("graphology-layout/random: given dimensions are invalid.");
      var center = options.center;
      var scale = options.scale;
      var tau = Math.PI * 2;
      var offset = (center - 0.5) * scale;
      var l = graph.order;
      var x = dimensions[0];
      var y = dimensions[1];
      function assignPosition(i2, target) {
        target[x] = scale * Math.cos(i2 * tau / l) + offset;
        target[y] = scale * Math.sin(i2 * tau / l) + offset;
        return target;
      }
      var i = 0;
      if (!assign) {
        var positions = {};
        graph.forEachNode(function(node) {
          positions[node] = assignPosition(i++, {});
        });
        return positions;
      }
      graph.updateEachNodeAttributes(
        function(_, attr) {
          assignPosition(i++, attr);
          return attr;
        },
        {
          attributes: dimensions
        }
      );
    }
    var circularLayout = genericCircularLayout.bind(null, false);
    circularLayout.assign = genericCircularLayout.bind(null, true);
    module.exports = circularLayout;
  }
});
export default require_circular();
//# sourceMappingURL=graphology-layout_circular__js.js.map
